package edu.kriogenik.infoloader.typeclasses

/**
 * Класс типов, описывающий сущность `функтор`.
 * Она является контейнером, в котором могут производится преобразования
 * без изменения самой структуры контейнера.
 *
 * @tparam F
 *          Тип контейнера, для которого определяется класс.
 */
trait Functor[F[_]] {

  /**
   * Функция высшего порядка, преобразующая значение функтора.
   *
   * @param fa
   *         Функтор, значение которого требуется преобразовать.
   * @param f
   *         Функция, которую требуется применить к функтору.
   * @tparam A
   *         Тип значения в переданном функторе.
   * @tparam B
   *         Тип значения в результирующем функторе.
   * @return
   *         Функтор с примененной к его значению функтором.
   */
  def fmap[A, B](fa: F[A])(f: A => B): F[B]

  /**
   * Функция, возвращающая объект функтора с заданным аргументом.
   *
   * @param a
   *         Аргумент для хранения в функторе.
   * @tparam A
   *         Тип аргумента для хранения в функотре.
   * @return
   *         Объект функтора с переданным значением.
   */
  def pure[A](a: A): F[A]

}


/**
 * Объект для удобного использования класса типа `функтор`.
 */
object Functor{

  /**
   * Функция для более удобного использования объекта класса типа.
   * Позволяет упростись получение объекта.
   * {{{
   * До:    implicitly[Functor[X]].(...)
   * После: Functor[X].(...)
   * }}}
   *
   * @param ff
   *         Реализация класса типа, получается неявно.
   * @tparam F
   *         Тип, для которого требуется получение реализации функтора.
   * @return
   *         Реализацию нужного класса типа для данного типа.
   */
  def apply[F[_]](implicit ff: Functor[F]): Functor[F] = ff

  /**
   * Неявный класс-расширение для использования возможностей класса типов
   * в ООП-стиле.
   * @param x
   *           Объект, для которого имеется реализация функтора.
   * @param ff
   *           Реализация функтора для заданного типа, неявный аргумент.
   * @tparam F
   *           Тип, для которого требуется реализация функтора.
   * @tparam A
   *           Тип значения, хранящегося в данном функторе.
   */
  implicit class FunctorOps[F[_]: Functor, A](x: F[A])(implicit ff: Functor[F]){
    /**
     * Функция для преобразования значения функтора.
     * @param f
     *          Функция, применяемая к значению функтора.
     * @tparam B
     *          Тип результата применения функции.
     * @return
     *          Функтор с примененной к нему функцией.
     */
    def fmap[B](f: A => B): F[B] = (ff fmap x) (f)
  }

}
