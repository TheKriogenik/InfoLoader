package edu.kriogenik.infoloader.typeclasses

/**
 * Класс типов, описывающий сущность `аппликативный функтор`.
 * Его отличие от простого функтора заключается в том, что
 * он позволяет применять один фуктор к другому, выстраивая тем
 * самым цепочку вычислений из фукторов и их аргументов.
 *
 * @tparam F
 *          Тип контейнера, для которого определяется класс типа.
 */
trait Applicative[F[_]] extends Functor[F]{ self =>

  /**
   * Аналог функции
   * [[edu.kriogenik.infoloader.typeclasses.Functor]]
   * для аппликативного функтора. Название изменено во избежание возможных коллизий
   * при выводе типа.
   * @param fa
   *           Функтор с аргументом.
   * @param f
   *          Функтор с функцией, применяемой к аргументу функтора `fa`.
   * @tparam A
   *           Тип аргумента первого функтора.
   * @tparam B
   *           Тип аргумента результирующего функтора.
   * @return
   *         Функтор с примененной к нему функцией из функтора `f`.
   */
  def apply[A, B](fa: F[A])(f: F[A => B]): F[B]

  override final def fmap[A, B](fa: F[A])(f: A => B): F[B] = self.apply(fa)(pure(f))

}

/**
 * Объект для удобного использования класса типа `аппликативный функтор`.
 */
object Applicative{

  /**
   * Функция для более удобного использования объекта класса типа.
   * Позволяет упростись получение объекта.
   * {{{
   * До:    implicitly[Applicative[X]].(...)
   * После: Applicative[X].(...)
   * }}}
   *
   * @param fa
   *         Реализация класса типа, получается неявно.
   * @tparam F
   *         Тип, для которого требуется получение реализации
   *         аппликативного функтора.
   * @return
   *         Реализацию нужного класса типа для данного типа.
   */
  final def apply[F[_]](implicit fa: Applicative[F]): Applicative[F] = fa

  /**
   * Неявный класс-расширение для аппликативных функторов, для более
   * удобного использования аппликативного функтора, когда первый функтор
   * является аргументом.
   * @param x
   *           Объект с аргументом, для которого имеется реализация
   *           аппликативного функтора.
   * @param fa
   *           Реализация аппликативного функтора для заданного типа,
   *           неявный аргумент.
   * @tparam F
   *           Тип, для которого требуется реализация аппликативного
   *           функтора.
   * @tparam A
   *           Тип значения, хранящегося в данном аппликативном функторе.
   */
  implicit class ApplicativeOps[F[_], A](x: F[A])(implicit fa: Applicative[F]){
    /**
     * Функция для преобразования значения функтора.
     * @param f
     *          Функция, применяемая к значению функтора.
     * @tparam B
     *          Тип результата применения функции.
     * @return
     *          Функтор с примененной к нему функцией.
     */
    final def *>[B](f: F[A => B]): F[B] = fa(x)(f)
  }

  /**
   * Неявный класс-расширение для аппликативных функторов, для более
   * удобного использования аппликативного функтора, когда первый функтор
   * является функцией.
   * @param x
   *          Объект с функцией, для которого имеется реализация
   *          аппликативного функтора.
   * @param af
   *           Реализация аппликативного функтора для заданного типа,
   *           неявный аргумент.
   * @tparam F
   *           Тип, для которого требуется реализация аппликативного
   *           функтора.
   * @tparam A
   *           Тип аргумента хранящейся функции.
   * @tparam B
   *           Тип результата применения хранящейся функции.
   */
  implicit class ApplicativeFunctionOps[F[_], A, B](x: F[A => B])(implicit af: Applicative[F]){
    /**
     * Функция, применяющая аргумент из функтора к хранящейся в обернутой
     * аппликативном функторе функции.
     * @param fa
     *          Аппликативный функтор, аргумент из которого будет применен.
     * @return
     *          Аппликативный функтор с примененным к нему аргументов.
     */
    final def <*>(fa: F[A]): F[B] = af(fa)(x)
  }

}
